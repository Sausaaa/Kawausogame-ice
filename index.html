<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ã‚«ãƒ¯ã‚¦ã‚½æ»‘ã‚Šã‚²ãƒ¼ãƒ  DX - ã‚¹ãƒãƒ›å¯¾å¿œç‰ˆ</title>
<style>
body{
  background:#34495e;
  color:white;
  text-align:center;
  font-family:'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
  margin: 0;
  padding: 10px;
  overflow-x: hidden;
}
h2 { font-size: 1.4rem; margin: 10px 0; }

/* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¹ãƒãƒ›ç”»é¢ã®å¹…ã«åˆã‚ã›ã¦è‡ªå‹•ãƒªã‚µã‚¤ã‚º */
canvas{
  border:4px solid #ffffff;
  border-radius: 15px;
  image-rendering: pixelated;
  background:#e0f7fa;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  max-width: 100%; /* ç”»é¢å¹…ã‚’è¶…ãˆãªã„ */
  height: auto;     /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ */
}

.controls {
  background: rgba(255,255,255,0.15);
  padding: 15px;
  border-radius: 30px;
  display: inline-block;
  margin-top: 10px;
  border: 2px solid #ffffff;
  width: 90%;
  max-width: 500px;
}

/* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒ‡ã§æ“ä½œã—ã‚„ã™ãå¤ªã */
input[type=range] {
  -webkit-appearance: none;
  width: 70%;
  height: 15px;
  background: #5d8aa8;
  border-radius: 10px;
  outline: none;
}

input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 45px;
  height: 40px;
  background: #a67c52;
  border: 3px solid #5d4037;
  border-radius: 40% 40% 45% 45%;
  cursor: pointer;
  background-image: 
    radial-gradient(circle at 35% 40%, #2b1b17 2px, transparent 2px),
    radial-gradient(circle at 65% 40%, #2b1b17 2px, transparent 2px),
    radial-gradient(circle at 50% 60%, #3d2b1f 3px, transparent 3px);
  background-repeat: no-repeat;
}

button{ 
  padding: 12px 24px;
  font-size:18px; 
  cursor: pointer;
  background: #f39c12;
  border: none;
  border-bottom: 4px solid #d35400;
  color: white;
  border-radius: 15px;
  font-weight: bold;
  margin: 5px;
  touch-action: manipulation;
}
button:active { transform: translateY(2px); border-bottom-width: 2px; }
button:disabled { background: #7f8c8d; border: none; }

.retry-btn { background: #27ae60; border-bottom: 4px solid #1e8449; }
.end-btn { background: #e74c3c; border-bottom: 4px solid #c0392b; }

#info { 
  font-size: 16px; 
  margin: 10px auto; 
  background: #f1c40f; 
  color: #333; 
  padding: 8px 15px; 
  border-radius: 10px; 
  display: block;
  max-width: 90%;
  font-weight: bold;
  line-height: 1.4;
}
</style>
</head>
<body>

<h2>ğŸ™ã‚«ãƒ¯ã‚¦ã‚½ã‚¢ã‚¤ã‚¹ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ğŸ™</h2>
<div class="controls" id="controlsArea">
  <span style="font-weight:bold">é«˜</span>
  <input type="range" id="slider" min="0" max="100" value="30">
  <span style="font-weight:bold">ä½</span>
  <br><br>
  <button id="startBtn" onclick="startGame()">æ»‘èµ°ã‚¹ã‚¿ãƒ¼ãƒˆï¼</button>
</div>
<br>
<div id="info">100mä»¥å†…ã«2å›é€£ç¶šæ­¢ã¾ã‚‹ã¨ã€ãŠã«ãã‚ŠãŒã‚‚ã‚‰ãˆã‚‹ã‚ˆï¼<br><small>ï¼ˆã‚ã¨10å›ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ï¼‰</small></div>
<br>
<canvas id="cv" width="1000" height="320"></canvas>

<script>
const ctx = cv.getContext("2d");
const SEA_X = 660;
const GROUND_Y = 240;
const WATER_SURFACE = GROUND_Y + 15;

let slope = 0.4;
let otter = { x: 150, y: 100, vx: 0, swimSpeed: 1.2 };
let state="ready";
let records=[];
let jumpT=0;
let tailAngle = 0;
let clouds=[];
let rainDrops=[];
let isRaining = false;
let onigiriCount = 0;
let winStreak = 0;
let playCount = 0;
let endingOnigiriPos = []; 
let glitterT = 0;

// åˆæœŸè¨­å®šï¼ˆå¤©å€™ãªã©ï¼‰
function initWeather(){
  isRaining = Math.random() < 0.4;
  clouds=[];
  for(let i=0;i<6;i++){
    clouds.push({x:Math.random()*1000, y:20+Math.random()*60, s:0.2+Math.random()*0.5});
  }
  rainDrops = [];
  for(let i=0; i<60; i++) {
    rainDrops.push({x: Math.random()*1100, y: Math.random()*320, v: 6 + Math.random()*4});
  }
}

// ãŠã«ãã‚Šæç”»
function drawOnigiri(ox, oy, scale=1) {
    ctx.lineWidth = 2.5 * scale;
    ctx.strokeStyle = "#2c3e50";
    ctx.fillStyle = "white";
    ctx.lineJoin = "round";
    const w = 18 * scale, h = 18 * scale, r = 8 * scale;
    ctx.beginPath();
    ctx.moveTo(ox, oy - h);
    ctx.arcTo(ox + w, oy + h, ox - w, oy + h, r);
    ctx.arcTo(ox - w, oy + h, ox, oy - h, r);
    ctx.arcTo(ox, oy - h, ox + w, oy + h, r);
    ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#2c3e50";
    ctx.beginPath();
    if(ctx.roundRect) ctx.roundRect(ox - (6*scale), oy + (5*scale), 12*scale, 10*scale, 2*scale);
    else ctx.fillRect(ox - (6*scale), oy + (5*scale), 12*scale, 10*scale);
    ctx.fill();
}

// èƒŒæ™¯æç”»
function drawBackground(){
  if(isRaining) {
    ctx.fillStyle = "#708090";
    ctx.fillRect(0,0,1000,320);
  } else {
    let grad = ctx.createLinearGradient(0,0,0,320);
    grad.addColorStop(0, "#bfe6ff"); grad.addColorStop(1, "#ffffff");
    ctx.fillStyle = grad; ctx.fillRect(0,0,1000,320);
    ctx.fillStyle="#f1c40f"; ctx.beginPath(); ctx.arc(80,50,25,0,Math.PI*2); ctx.fill();
  }
  ctx.fillStyle="white";
  clouds.forEach(c=>{
    ctx.globalAlpha = isRaining ? 0.4 : 0.9;
    ctx.beginPath(); ctx.arc(c.x, c.y, 15, 0, Math.PI*2); ctx.arc(c.x+15, c.y-10, 18, 0, Math.PI*2); ctx.arc(c.x+35, c.y, 15, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1.0; c.x += c.s; if(c.x > 1050) c.x = -60;
  });
  if(isRaining) {
    ctx.strokeStyle = "#3498db"; ctx.lineWidth = 2;
    rainDrops.forEach(r => {
      ctx.beginPath(); ctx.moveTo(r.x, r.y); ctx.lineTo(r.x - 4, r.y + 12); ctx.stroke();
      r.y += r.v; r.x -= r.v * 0.3; if(r.y > 320) { r.y = -20; r.x = Math.random()*1100; }
    });
  }
}

// ã‚«ãƒ¯ã‚¦ã‚½æç”»ãƒ‘ãƒ¼ãƒ„
function px(x, y, dx, dy, w, h, c, scale=2){
  ctx.fillStyle = c; ctx.fillRect(x + dx*scale, y + dy*scale, w*scale, h*scale);
}

// ã‚«ãƒ¯ã‚¦ã‚½æœ¬ä½“
function drawOtter(x, y, mode, customScale=2){
  const body = "#a67c52", dark = "#5d4037", belly = "#fdf5e6", eye = "#2b1b17", nose = "#3d2b1f", cheek = "#ff89b0";
  ctx.save(); ctx.translate(x, y);
  if(mode === "ready"){
    tailAngle = Math.sin(Date.now() / 150) * 0.4;
    ctx.save(); ctx.translate(3*customScale, 15*customScale); ctx.rotate(tailAngle);
    px(0, 0, -6, -2, 6, 4, dark, customScale); ctx.restore();
  }
  if(mode === "stand" || mode === "ready" || mode === "sad"){
    px(0,0, 10, 14, 4, 3, dark, customScale); px(0,0, 3, 17, 3, 2, dark, customScale); px(0,0, 8, 17, 3, 2, dark, customScale);
    px(0,0, 3, 6, 8, 11, dark, customScale); px(0,0, 4, 7, 6, 10, body, customScale); px(0,0, 5, 8, 4, 8, belly, customScale);
    px(0,0, 2, 9, 2, 4, dark, customScale); px(0,0, 10, 9, 2, 4, dark, customScale); px(0,0, 2, 0, 10, 7, dark, customScale);
    px(0,0, 3, 1, 8, 5, body, customScale); px(0,0, 4, 5, 6, 2, belly, customScale);
    if(mode === "sad") {
      px(0,0, 4, 4, 2, 1, eye, customScale); px(0,0, 9, 4, 2, 1, eye, customScale);
      px(0,0, 6, 5, 2, 1, nose, customScale);
    } else {
      px(0,0, 4, 3, 1, 1, eye, customScale); px(0,0, 9, 3, 1, 1, eye, customScale);
      px(0,0, 6, 4, 2, 1, nose, customScale);
    }
    px(0,0, 2, 0, 2, 2, dark, customScale); px(0,0, 10, 0, 2, 2, dark, customScale);
    px(0,0, 3, 4, 1, 1, cheek, customScale); px(0,0, 10, 4, 1, 1, cheek, customScale);
  } else if(mode === "eating"){
    const s = customScale;
    px(0,0, 3, 8, 12, 14, dark, s); px(0,0, 4, 9, 10, 12, body, s); px(0,0, 5, 12, 8, 8, belly, s);
    px(0,0, 2, 0, 14, 9, dark, s); px(0,0, 3, 1, 12, 7, body, s); px(0,0, 4, 6, 10, 3, belly, s);
    px(0,0, 2, 0, 3, 3, dark, s); px(0,0, 13, 0, 3, 3, dark, s);
    px(0,0, 5, 3, 2, 2, eye, s); px(0,0, 11, 3, 2, 2, eye, s); px(0,0, 8, 5, 2, 1, nose, s);
    px(0,0, 4, 5, 2, 2, cheek, s); px(0,0, 12, 5, 2, 2, cheek, s);
    px(0,0, 2, 12, 4, 4, dark, s); px(0,0, 12, 12, 4, 4, dark, s);
    drawOnigiri(9*s, 15*s, 0.8 * (s/2));
  } else {
    px(0,0, -2, 10, 5, 3, dark, customScale); px(0,0, 2, 7, 13, 7, dark, customScale);
    px(0,0, 3, 8, 11, 5, body, customScale); px(0,0, 5, 10, 8, 3, belly, customScale); 
    px(0,0, 10, 4, 8, 7, dark, customScale); px(0,0, 11, 5, 6, 5, body, customScale);
    px(0,0, 11, 3, 2, 2, dark, customScale); px(0,0, 16, 3, 2, 2, dark, customScale);
    px(0,0, 12, 6, 1, 1, eye, customScale); px(0,0, 15, 6, 1, 1, eye, customScale);
    px(0,0, 13, 7, 2, 1, nose, customScale);
  }
  ctx.restore();
}

function groundY(x){
  if(x < 350) return GROUND_Y - (350 - x) * slope;
  if(x < SEA_X) return GROUND_Y;
  return GROUND_Y + 50;
}

function drawGround(){
  let iceGrad = ctx.createLinearGradient(0, 0, SEA_X, 320);
  iceGrad.addColorStop(0, "#e0f7fa"); iceGrad.addColorStop(1, "#81d4fa");
  ctx.fillStyle = iceGrad; ctx.beginPath(); ctx.moveTo(0,320); ctx.lineTo(0, groundY(0));
  for(let x=0; x<=SEA_X; x+=10) ctx.lineTo(x, groundY(x));
  ctx.lineTo(SEA_X, 320); ctx.fill();
  ctx.fillStyle="#3498db"; ctx.fillRect(SEA_X, WATER_SURFACE, 1000, 320);
  ctx.strokeStyle = "white"; ctx.lineWidth = 3;
  for(let i=0; i<3; i++){
    ctx.beginPath();
    for(let wx=SEA_X; wx<=1000; wx+=20){
      let wy = WATER_SURFACE + 20 + i*40 + Math.sin(wx/30 + Date.now()/400)*5;
      if(wx === SEA_X) ctx.moveTo(wx, wy); else ctx.lineTo(wx, wy);
    }
    ctx.stroke();
  }
}

function drawGlitter(x, y) {
  if (glitterT <= 0) return;
  const time = Date.now() / 100;
  ctx.fillStyle = "#f1c40f";
  for(let i=0; i<6; i++) {
    const angle = (i * 60) * Math.PI / 180;
    const dist = 40 + Math.sin(time + i) * 10;
    ctx.beginPath(); ctx.arc(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist, 4, 0, Math.PI*2); ctx.fill();
  }
  glitterT--;
}

function startGame(){
  if(state !== "ready") return;
  playCount++;
  slope = 0.35 + Math.random() * 0.15;
  const s = slider.value / 100;
  const startX = 30 + (400 * s); 
  otter = { x: startX, vx: Math.sqrt(Math.max(0.1, (350 - startX) * slope)) * (isRaining ? 1.05 : 1.1), y: groundY(startX)-22 };
  state = "slide";
  slider.disabled = true; startBtn.disabled = true;
}

function loop(){
  ctx.clearRect(0,0,1000,320);
  if(state === "ending_eat"){
    ctx.fillStyle = "#e0f7fa"; ctx.fillRect(0,0,1000,320);
    endingOnigiriPos.forEach(p => drawOnigiri(p.x, p.y + Math.sin(Date.now()/500 + p.x)*5, 0.7));
    ctx.fillStyle = "#2c3e50"; ctx.font = "bold 32px sans-serif"; ctx.fillText("ã‚€ã—ã‚ƒã‚€ã—ã‚ƒï¼ãŠã„ã—ã„ï¼", 300, 60);
    drawOtter(420, 100, "eating", 6); requestAnimationFrame(loop); return;
  }
  if(state === "ending_sad"){
    ctx.fillStyle = "#d1d8e0"; ctx.fillRect(0,0,1000,320);
    ctx.fillStyle = "#2c3e50"; ctx.font = "bold 32px sans-serif"; ctx.fillText("ãŠã«ãã‚Šã€é£Ÿã¹ãŸã‹ã£ãŸãªã...", 280, 60);
    drawOtter(420, 130, "sad", 6); requestAnimationFrame(loop); return;
  }

  drawBackground();
  drawGround();
  for(let i=0; i<onigiriCount; i++) drawOnigiri(40 + (i * 50), 40);

  if(state === "ready"){
    const s = slider.value / 100; otter.x = 30 + (400 * s); otter.y = groundY(otter.x) - 70;
    drawOtter(otter.x, otter.y, "ready");
  } else if(state === "slide"){
    otter.x += otter.vx; otter.y = groundY(otter.x) - 22; otter.vx *= (otter.x > 350) ? (isRaining ? 0.98 : 0.972) : 1;
    if(otter.x <= 350) otter.vx += 0.05; drawOtter(otter.x, otter.y, "slide");
    if(otter.x >= SEA_X - 25) finish("fall");
    else if(otter.vx < 0.15) { state = "jump"; jumpT = 0; }
  } else if(state === "jump"){
    jumpT++; const jumpH = Math.abs(Math.sin(jumpT/15 * Math.PI)) * 25; drawOtter(otter.x, groundY(otter.x) - 45 - jumpH, "stand");
    if(jumpT > 45) finish(Math.max(0, Math.floor(SEA_X - otter.x - 35)));
  } else if(state === "success"){
    drawOtter(otter.x, groundY(otter.x) - 45, "stand"); drawGlitter(otter.x + 20, groundY(otter.x) - 80);
  } else if(state === "finished_fail"){
    otter.y = WATER_SURFACE + 30; otter.x += 1.2; drawOtter(otter.x, otter.y, "slide");
  }
  requestAnimationFrame(loop);
}

function finish(dist){
  let resultMsg = "";
  if(dist === "fall") { resultMsg = "æµ·ã«è½ã¡ã¡ã‚ƒã£ãŸ...ï¼"; winStreak = 0; state = "finished_fail"; }
  else {
    state = "success";
    if(dist <= 100) { 
      winStreak++; 
      if(winStreak >= 2) { onigiriCount++; resultMsg = `è¨˜éŒ² ${dist}mï¼ ğŸ™ãŠã«ãã‚Šç²å¾—ï¼`; winStreak = 0; glitterT = 100; }
      else resultMsg = `è¨˜éŒ² ${dist}mï¼ ã‚ã¨1å›ã§ãŠã«ãã‚Šï¼`;
    } else { winStreak = 0; resultMsg = `è¨˜éŒ² ${dist}mï¼ 100mä»¥å†…ã‚’ç›®æŒ‡ãã†`; }
    records.push(dist);
  }
  
  let btns = `<button class="retry-btn" onclick="resetGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>`;
  if(playCount >= 10) {
    resultMsg = "10å›ãƒ—ãƒ¬ã‚¤å®Œäº†ï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼<br>" + resultMsg;
    btns = `<button class="end-btn" onclick="endGame()">ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã™ã‚‹</button>`;
  } else { resultMsg += `<br><small>ï¼ˆã‚ã¨${10 - playCount}å›ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ï¼‰</small>`; }
  info.innerHTML = `${resultMsg}<br><small>æœ€è¿‘ã®è¨˜éŒ²: ${records.slice(-3).join("m, ")}m</small><br>${btns}`;
}

function resetGame(){
  state = "ready"; slider.disabled = false; startBtn.disabled = false;
  info.innerHTML = `100mä»¥å†…ã«2å›é€£ç¶šæ­¢ã¾ã‚‹ã¨ãŠã«ãã‚Šç²å¾—ï¼<br><small>ï¼ˆã‚ã¨${10 - playCount}å›ãƒ—ãƒ¬ã‚¤ã§ãã¾ã™ï¼‰</small>`;
  initWeather();
}

function endGame(){
  document.getElementById("controlsArea").style.display = "none";
  if(onigiriCount >= 1) {
    endingOnigiriPos = [];
    for(let i=0; i<onigiriCount; i++) endingOnigiriPos.push({ x: 100 + Math.random() * 800, y: 100 + Math.random() * 180 });
    state = "ending_eat";
    info.innerHTML = `ãŠã«ãã‚Šã‚’ ${onigiriCount} å€‹ç²å¾—ï¼ã‚«ãƒ¯ã‚¦ã‚½ã¯å¤§æº€è¶³ã§ã™ï¼<br><button class="retry-btn" onclick="location.reload()">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>`;
  } else {
    state = "ending_sad";
    info.innerHTML = `ãŠã«ãã‚Šã¯ 0 å€‹ã§ã—ãŸ...ã€‚<br><button class="retry-btn" onclick="location.reload()">å†æŒ‘æˆ¦ã™ã‚‹</button>`;
  }
}

initWeather();
loop();
</script>
</body>
</html>
